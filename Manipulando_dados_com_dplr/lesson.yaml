- Class: meta
  Course: Obtencao e Limpeza de Dados
  Lesson: Manipulando dados com dplr
  Author: Nick Carchedi (Tradução Murilo Junqueira)
  Type: Standard
  Organization: JHU Biostat
  Version: 2.4.4


- Class: text
  Output: Nesta lição, você aprenderá como manipular dados usando o dplyr. O dplyr é um pacote R rápido e poderoso, escrito por Hadley Wickham e Romain Francois, que fornece uma gramática consistente e concisa para manipular dados tabulares.

- Class: text
  Output: Um aspecto exclusivo do dplyr é que o mesmo conjunto de ferramentas permite trabalhar com dados tabulares de várias fontes, incluindo quadros de dados, tabelas de dados, bancos de dados e matrizes multidimensionais. Nesta lição, focaremos nos bancos de dados (data frames), mas tudo o que você aprender se aplicará igualmente a outros formatos.

- Class: text
  Output: 'Como você deve saber, "CRAN é uma rede de servidores FTP e Web em todo o mundo que armazena versões idênticas e atualizadas de código e documentação para R" (http://cran.rstudio.com/). O RStudio mantém um desses chamados '' espelhos CRAN '' e eles disponibilizam publicamente seus logs de download (http://cran-logs.rstudio.com/). Estamos trabalhando com o log desde 8 de julho de 2014, desde então já foram registrados mais de 225.000 downloads de pacotes.'

- Class: cmd_question
  Output: "Eu criei uma variável chamada path2csv, que contém o caminho completo do arquivo para o conjunto de dados. Chame read.csv () com dois argumentos, path2csv e stringsAsFactors = FALSE, e salve o resultado em uma nova variável chamada mydf.  Verifique ?read.csv se precisar de ajuda."
  CorrectAnswer: mydf <- read.csv(path2csv, stringsAsFactors = FALSE)
  AnswerTests: omnitest(correctExpr='mydf <- read.csv(path2csv, stringsAsFactors = FALSE)')
  Hint: Armazene o resultado de read.csv (path2csv, stringsAsFactors = FALSE) em uma nova variável chamada mydf.

- Class: cmd_question
  Output: Use dim() para examinar as dimensões do mydf.
  CorrectAnswer: dim(mydf)
  AnswerTests: omnitest(correctExpr='dim(mydf)')
  Hint: dim(mydf) fornecerá as dimensões do conjunto de dados.

- Class: cmd_question
  Output: Agora use head() para visualizar os dados.
  CorrectAnswer: head(mydf)
  AnswerTests: omnitest(correctExpr='head(mydf)')
  Hint: head(mydf) mostrará as seis primeiras linhas de mydf.

- Class: cmd_question
  Output: O pacote dplyr foi instalado automaticamente (se necessário) e carregado no início desta lição. Normalmente, isso é algo que você teria que fazer por conta própria. Apenas para criar o hábito, digite library(dplyr) agora para carregar o pacote novamente.
  CorrectAnswer: library(dplyr)
  AnswerTests: omnitest(correctExpr='library(dplyr)')
  Hint: Use a library(dplyr) para carregar o pacote dplyr.

- Class: cmd_question
  Output: É importante que você tenha o dplyr versão 0.4.0 ou posterior. Para confirmar isso, digite packageVersion("dplyr").
  CorrectAnswer: packageVersion("dplyr")
  AnswerTests: omnitest(correctExpr='packageVersion("dplyr")')
  Hint: Verifique qual versão do dplyr você possui com packageVersion("dplyr").

- Class: text
  Output: Se sua versão do dplyr não for pelo menos 0.4.0, pressione a tecla Esc agora, reinstale o dplyr e retome esta lição de onde parou.

- Class: cmd_question
  Output: "A primeira etapa do trabalho com dados no dplyr é carregar os dados no que os autores do pacote chamam de 'data frame tbl' ou 'tbl_df'. Use o código a seguir para criar um novo tbl_df chamado cran:\n\ncran <- tbl_df(mydf)."
  CorrectAnswer: cran <- tbl_df(mydf)
  AnswerTests: omnitest(correctExpr='cran <- tbl_df(mydf)')
  Hint: Digite cran <- tbl_df(mydf) para criar um novo tbl_df chamado cran.

- Class: cmd_question
  Output: Para evitar confusão e manter as coisas funcionando sem problemas, vamos remover o quadro de dados original do seu espaço de trabalho com rm("mydf").
  CorrectAnswer: rm("mydf")
  AnswerTests: omnitest(correctExpr='rm("mydf")')
  Hint: Use rm ("mydf") para remover o quadro de dados original do seu workspace (o workspace é tipo a memória do R).

- Class: cmd_question
  Output: Na documentação que você pode obter em ?Tbl_df - "A principal vantagem de usar um tbl_df ao invés de um data frame regular é a impressão na tela." Vamos ver o que se entende por isso. Digite cran para imprimir nosso tbl_df no console.
  CorrectAnswer: cran
  AnswerTests: omnitest(correctExpr='cran')
  Hint: Digite cran para imprimir nosso tbl_df no console.

- Class: text
  Output: Essa saída é muito mais informativa e compacta do que seria possível se imprimíssemos o data frame original (mydf) no console.

- Class: text
  Output: Primeiro, são mostradas a classe e as dimensões do conjunto de dados. Logo abaixo disso, obtemos uma visualização dos dados. Em vez de tentar imprimir o conjunto de dados inteiro, o dplyr apenas mostra as 10 primeiras linhas de dados e apenas quantas colunas cabem perfeitamente em nosso console. Na parte inferior, vemos os nomes e as classes de todas as variáveis que não se encaixam em nossa tela.

- Class: text
  Output: 'De acordo com a vinheta "Introdução ao dplyr", escrita pelos autores do pacote, "A filosofia do dplyr é ter pequenas funções, cada uma fazendo bem uma coisa". Especificamente, o dplyr fornece cinco '' verbos '' que cobrem as tarefas mais fundamentais de manipulação de dados: select(), filter(), arrange(), mutate() e summarize().'

- Class: cmd_question
  Output: Use ?select para exibir a documentação da primeira dessas funções principais.
  CorrectAnswer: ?select
  AnswerTests: omnitest(correctExpr='?select')
  Hint: ?select exibirá a documentação para a função select() do dplyr.
  
- Class: text
  Output: Os arquivos de ajuda para as outras funções são acessíveis da mesma maneira.

- Class: cmd_question
  Output: Como geralmente pode ser o caso, particularmente em conjuntos de dados maiores, estamos interessados apenas em algumas das variáveis. Use select(cran, ip_id, package, country) para selecionar apenas as variáveis ip_id, package e country do conjunto de dados do cran.
  CorrectAnswer: select(cran, ip_id, package, country)
  AnswerTests: omnitest(correctExpr='select(cran, ip_id, package, country)')
  Hint: Digite select (cran, ip_id, packag, country) para selecionar apenas as variáveis ip_id, package e country do conjunto de dados do cran.

- Class: text
  Output: A primeira coisa a notar é que não precisamos digitar cran$ip_id, cran$package e cran$country, como normalmente faria quando se refere a colunas de um quadro de dados. A função select() sabe que estamos nos referindo às colunas do conjunto de dados do cran.

- Class: text
  Output: Além disso, observe que as colunas são retornadas na ordem que especificamos, embora ip_id seja a coluna mais à direita no conjunto de dados original.

- Class: cmd_question
  Output: Lembre-se que em R, o operador `:` fornece uma notação compacta para criar uma sequência de números. Por exemplo, tente 5:20.
  CorrectAnswer: 5:20
  AnswerTests: omnitest(correctExpr='5:20')
  Hint: Digite 5:20 para ver como `:` pode ser usado para criar uma sequência de números.

- Class: cmd_question
  Output: Normalmente, essa notação é reservada para números, mas select() permite que você especifique uma sequência de colunas dessa maneira, o que pode economizar bastante digitação. Use select(cran, r_arch:country) para selecionar todas as colunas começando em r_arch e terminando com country.
  CorrectAnswer: select(cran, r_arch:country)
  AnswerTests: omnitest(correctExpr='select(cran, r_arch:country)')
  Hint: select(cran, r_arch:country) will select all columns from r_arch through country (left to right).

- Class: cmd_question
  Output: Também podemos selecionar as mesmas colunas na ordem inversa. Tente isso!
  CorrectAnswer: select(cran, country:r_arch)
  AnswerTests: omnitest(correctExpr='select(cran, country:r_arch)')
  Hint: select(cran, country:r_arch) selecionará todas as colunas que começam no country e terminam com r_arch (da direita para a esquerda).

- Class: cmd_question
  Output: Imprima o conjunto de dados inteiro novamente, apenas para se lembrar de como ele é. Você pode fazer isso a qualquer momento durante a lição.
  CorrectAnswer: cran
  AnswerTests: omnitest(correctExpr='cran')
  Hint: Imprima o guindaste no console para se lembrar de como ele é.

- Class: cmd_question
  Output: Em vez de especificar as colunas que queremos manter, também podemos especificar as colunas que queremos jogar fora. Para ver como isso funciona, select(cran, -time) para omitir a coluna de tempo.
  CorrectAnswer: select(cran, -time)
  AnswerTests: omnitest(correctExpr='select(cran, -time)')
  Hint: Use select (cran, -time) para se livrar da coluna do tempo.

- Class: cmd_question
  Output: O sinal negativo na frente do tempo indica ao select() que NÃO queremos a coluna do tempo. Agora, vamos combinar estratégias para omitir todas as colunas de X a size (X:size). Para ver como isso pode funcionar, vejamos um exemplo numérico com -5:20.
  CorrectAnswer: -5:20
  AnswerTests: omnitest(correctExpr='-5:20')
  Hint: Veja o que -5:20 nos dá.

- Class: cmd_question
  Output: Opa! Isso nos gera um vetor de números de -5 a 20, que não é o que queremos. Em vez disso, queremos negativar toda a sequência de números de 5 a 20, para obtermos -5, -6, -7, ..., -18, -19, -20. Tente a mesma coisa, exceto 5:20 deve estar entre parênteses, para que o R saiba que queremos primeiro a sequência de números e, em seguida, aplique o sinal negativo à coisa toda.
  CorrectAnswer: -(5:20)
  AnswerTests: omnitest(correctExpr='-(5:20)')
  Hint: -(5:20) fará o trabalho.

- Class: cmd_question
  Output: Use esse conhecimento para omitir todas as colunas X:size usando select().
  CorrectAnswer: select(cran, -(X:size))
  AnswerTests: omnitest(correctExpr='select(cran, -(X:size))')
  Hint: Use select(cran, -(X:size)) para omitir todas as colunas do tamanho X ao size.

- Class: text
  Output: Agora que você sabe como selecionar um subconjunto de colunas usando select(), uma próxima pergunta natural é "Como faço para selecionar um subconjunto de linhas?" É aí que a função filter() entra.

- Class: cmd_question
  Output: Use o filter(cran, package == "swirl") para selecionar todas as linhas para as quais a variável do pacote é igual a "swirl". Certifique-se de usar dois sinais de igual lado a lado!
  CorrectAnswer: filter(cran, package == "swirl")
  AnswerTests: omnitest(correctExpr='filter(cran, package == "swirl")')
  Hint: filter(cran, package == "swirl") fornecerá apenas as linhas para as quais a variável do pacote é igual a "swirl".

- Class: text
  Output: Novamente, observe que filter() reconhece 'package' como uma coluna de cran, sem que você precise especificar explicitamente cran$package.

- Class: text
  Output: O operador == pergunta se a coisa à esquerda é igual à coisa à direita. Se sim, retorna TRUE. Se não, então FALSE. Nesse caso, package é um vetor inteiro (coluna) de valores; portanto, package == "swirl" retorna um vetor de TRUEs e FALSEs. filter() retorna apenas as linhas de cran correspondentes aos TRUEs.

- Class: cmd_question
  Output: Você pode especificar quantas condições desejar, separadas por vírgulas. Por exemplo, filter (cran, r_version == "3.1.1", country == "US") retornará todas as linhas de cran correspondentes aos downloads de usuários nos EUA executando a versão R 3.1.1. Experimente.
  CorrectAnswer: filter(cran, r_version == "3.1.1", country == "US")
  AnswerTests: any_of_exprs('filter(cran, r_version == "3.1.1", country == "US")', 'filter(cran, country == "US", r_version == "3.1.1")')
  Hint: filter(cran, r_version == "3.1.1", country == "US") retornará todas as linhas de cran correspondentes a downloads de usuários nos EUA executando a versão 3.1.1 do R. Não esqueça as aspas em torno de 3.1.1 e EUA!

- Class: cmd_question
  Output: As condições passadas para filter() podem fazer uso de qualquer um dos operadores de comparação padrão. Puxe a documentação relevante com ?Comparison (com C maiúsculo).
  CorrectAnswer: ?Comparison
  AnswerTests: omnitest(correctExpr='?Comparison')
  Hint: ?Comparison exibirá o arquivo de ajuda.

- Class: cmd_question
  Output: Edite seu comando anterior para filter() para retornar as linhas correspondentes aos usuários em "IN" (Índia) executando uma versão R menor ou igual a "3.0.2". A seta para cima do teclado pode ser útil aqui. Não esqueça suas aspas duplas!
  CorrectAnswer: filter(cran, r_version <= "3.0.2", country == "IN")
  AnswerTests: any_of_exprs('filter(cran, r_version <= "3.0.2", country == "IN")', 'filter(cran, country == "IN", r_version <= "3.0.2")')
  Hint: filter(cran, r_version <= "3.0.2", país == "IN") retornará todas as linhas para as quais r_version é menor ou igual a "3.0.2" e país é igual a "IN".

- Class: cmd_question
  Output: Nossas duas últimas chamadas para filter() solicitaram todas as linhas para as quais uma condição E outra condição eram VERDADEIRAS. Também podemos solicitar linhas para as quais UMA condição OU outra condição é VERDADEIRA. Por exemplo, filter(cran, country == "US" | country == "IN") nos fornece todas as linhas para as quais a variável do país é igual a "US" ou "IN". Dê uma chance.
  CorrectAnswer: filter(cran, country == "US" | country == "IN")
  AnswerTests: any_of_exprs('filter(cran, country == "US" | country == "IN")', 'filter(cran, country == "IN" | country == "US")')
  Hint: O filtro (cran, country == "US" | country == "IN") retornará todas as linhas cujo país seja igual a "US" ou "IN". O símbolo `|` (chamado de pipe operator) provavelmente compartilha uma tecla com a barra invertida no teclado.

- Class: cmd_question
  Output: 'Agora, use filter() para buscar todas as linhas cujo tamanho seja estritamente maior que (>) 100500 (sem aspas, pois o tamanho é numérico) E r_os é igual a "linux-gnu". Dica: Você está passando três argumentos para filter(): o nome do conjunto de dados, a primeira condição e a segunda condição.'
  CorrectAnswer: filter(cran, size > 100500, r_os == "linux-gnu")
  AnswerTests: any_of_exprs('filter(cran, size > 100500, r_os == "linux-gnu")', 'filter(cran, r_os == "linux-gnu", size > 100500)')
  Hint: Este é um assunto complicado. O filter(cran, tamanho> 100500, r_os == "linux-gnu") nos fornecerá todas as linhas cujo tamanho seja estritamente maior que 100500 e r_os seja "linux-gnu".

- Class: text
  Output: Finalmente, queremos obter apenas as linhas para as quais a r_version não está faltando. R representa valores ausentes com NA e esses valores ausentes podem ser detectados usando a função is.na().

- Class: cmd_question
  Output: Para ver como isso funciona, tente is.na(c (3, 5, NA, 10)).
  CorrectAnswer: is.na(c(3, 5, NA, 10))
  AnswerTests: omnitest('is.na(c(3, 5, NA, 10))')
  Hint: Tente is.na(c (3, 5, NA, 10)) para ver como is.na() funciona.

- Class: cmd_question
  Output: 'Agora, coloque um ponto de exclamação (!) Antes de is.na() para mudar todos os TRUEs para FALSEs e todos os FALSEs para TRUEs, dizendo-nos o que NÃO é NA:! is.na(c(3, 5, NA, 10)).'
  CorrectAnswer: "!is.na(c(3, 5, NA, 10))"
  AnswerTests: omnitest('!is.na(c(3, 5, NA, 10))')
  Hint: !is.na(c(3, 5, NA, 10)) negará o comando anterior, nos dizendo o que NÃO é NA.

- Class: cmd_question
  Output: 'Ok, pronto para juntar tudo isso? Use filter() para retornar todas as linhas de cran para as quais r_version NÃO é NA. Dica: Você precisará usar !is.na() como parte do seu segundo argumento para filter().'
  CorrectAnswer: filter(cran, !is.na(r_version))
  AnswerTests: omnitest('filter(cran, !is.na(r_version))')
  Hint: Este é outro comando complicado. filter(cran,!is.na(r_version)) retornará todas as linhas de cran para as quais r_version NÃO é NA.

- Class: text
  Output: Vimos como selecionar um subconjunto de colunas e linhas do nosso conjunto de dados usando select() e filter(), respectivamente. Inerente a select() também está a capacidade de organizar nossas colunas selecionadas em qualquer ordem que desejamos.

- Class: text
  Output: Às vezes, queremos ordenar as linhas de um conjunto de dados de acordo com os valores de uma variável específica. Este é o trabalho de arrange().

- Class: cmd_question
  Output: Para ver como o arrange() funciona, vamos primeiro pegar um subconjunto do cran. select() todas as colunas de size a ip_id e armazene o resultado no cran2.
  CorrectAnswer: cran2 <- select(cran, size:ip_id)
  AnswerTests: omnitest('cran2 <- select(cran, size:ip_id)')
  Hint: Use select(cran, size:ip_id) para selecionar todas as colunas, de size ao ip_id. Armazene o resultado em cran2.

- Class: cmd_question
  Output: Agora, para ordenar as LINHAS do cran2 de forma que ip_id esteja em ordem crescente (de pequeno a grande), digite arrange(cran2, ip_id). Você pode tornar seu console suficientemente amplo para poder ver ip_id, que é a última coluna.
  CorrectAnswer: arrange(cran2, ip_id)
  AnswerTests: omnitest('arrange(cran2, ip_id)')
  Hint: arrange(cran2, ip_id) ordenará as linhas do cran2 do menor ip_id para o maior ip_id.

- Class: cmd_question
  Output: Para fazer o mesmo, mas em ordem decrescente, altere o segundo argumento para desc(ip_id), onde desc() significa 'decrescente'. Continue.
  CorrectAnswer: arrange(cran2, desc(ip_id))
  AnswerTests: omnitest('arrange(cran2, desc(ip_id))')
  Hint: arrange(cran2, desc (ip_id)) ordenará as linhas do nosso conjunto de dados do maior ip_id para o menor ip_id.

- Class: cmd_question
  Output: Também podemos organizar os dados de acordo com os valores de várias variáveis. Por exemplo, o arrange(cran2, pacote, ip_id) primeiro organiza pelos nomes dos pacotes (em ordem alfabética crescente) e depois por ip_id. Isso significa que, se houver várias linhas com o mesmo valor para o pacote, elas serão classificadas por ip_id (crescente numericamente). Tente arrange(cran2, pacote, ip_id) agora.
  CorrectAnswer: arrange(cran2, package, ip_id)
  AnswerTests: omnitest('arrange(cran2, package, ip_id)')
  Hint: Use o arrange(cran2, pacote, ip_id) para classificar os dados principalmente pelo nome do pacote e, secundariamente, pelo ip_id.

- Class: cmd_question
  Output: 'Ordene cran2 pelas três variáveis a seguir, nesta ordem: country (crescente), r_version (decrescente) e ip_id (crescente).'
  CorrectAnswer: arrange(cran2, country, desc(r_version), ip_id)
  AnswerTests: omnitest('arrange(cran2, country, desc(r_version), ip_id)')
  Hint: arrange(cran2, country, desc (r_version), ip_id) classificará os dados por country (crescente) primeiro, depois por r_version (decrescente) e, finalmente, por ip_id (crescente).

- Class: cmd_question
  Output: 'Para ilustrar a próxima função principal no dplyr, vamos pegar outro subconjunto de nossos dados originais. Use select() para pegar 3 colunas de cran: ip_id, pacote e size (nessa ordem) - e armazene o resultado em uma nova variável chamada cran3.'
  CorrectAnswer: cran3 <- select(cran, ip_id, package, size)
  AnswerTests: omnitest('cran3 <- select(cran, ip_id, package, size)')
  Hint: cran3 <- select(cran, ip_id, pacote, tamanho) armazenará apenas essas três colunas em uma nova variável chamada cran3.

- Class: cmd_question
  Output: Dê uma olhada no cran3 agora.
  CorrectAnswer: cran3
  AnswerTests: any_of_exprs('cran3', 'print(cran3)')
  Hint: Digite cran3 para visualizar seu conteúdo.

- Class: text
  Output: É comum criar uma nova variável com base no valor de uma ou mais variáveis já presentes em um conjunto de dados. A função mutate() faz exatamente isso.

- Class: text
  Output: A variável size representa o tamanho do download em bytes, que são unidades de memória do computador. Atualmente, megabytes (MB) são a unidade de medida mais comum. Um megabyte é igual a 2^20 bytes. Isso é 2 na potência de 20, que é aproximadamente um milhão de bytes!

- Class: cmd_question
  Output: "Queremos adicionar uma coluna chamada size_mb que contenha o tamanho do download em megabytes. Aqui está o código para fazer isso:\n\nmutate(cran3, size_mb = size / 2^20)"
  CorrectAnswer: mutate(cran3, size_mb = size / 2^20)
  AnswerTests: omnitest('mutate(cran3, size_mb = size / 2^20)')
  Hint: mutate(cran3, size_mb = size / 2^20) adicionará uma nova coluna chamada size_mb que contém o tamanho do download em megabytes.

- Class: text
  Output: Uma unidade de memória ainda maior é um gigabyte (GB), que é igual a 2 ^ 10 megabytes. Também podemos adicionar outra coluna para o tamanho do download em gigabytes!

- Class: cmd_question
  Output: Um recurso muito bom de mutate() é que você pode usar o valor calculado para sua segunda coluna (size_mb) para criar uma terceira coluna, tudo na mesma linha de código. Para ver isso em ação, repita exatamente o mesmo comando acima, exceto adicione um terceiro argumento criando uma coluna denominada size_gb e igual a size_mb / 2^10.
  CorrectAnswer: mutate(cran3, size_mb = size / 2^20, size_gb = size_mb / 2^10)
  AnswerTests: omnitest('mutate(cran3, size_mb = size / 2^20, size_gb = size_mb / 2^10)')
  Hint: Use mutate(cran3, size_mb = size / 2^20, size_gb = size_mb / 2^10) para criar duas novas colunas chamadas size_mb e size_gb, respectivamente.

- Class: cmd_question
  Output: Vamos tentar mais um para praticar. Finja que descobrimos uma falha no sistema que forneceu os valores originais para a variável de tamanho. Todos os valores em cran3 são 1000 bytes menores do que deveriam. Usando cran3, crie apenas uma nova coluna chamada correct_size que contenha o tamanho correto.
  CorrectAnswer: mutate(cran3, correct_size = size + 1000)
  AnswerTests: omnitest('mutate(cran3, correct_size = size + 1000)')
  Hint: mutate(cran3, correct_size = tamanho + 1000) criará uma nova coluna igual aos tamanhos originais mais 1000.

- Class: cmd_question
  Output: O último dos cinco verbos principais do dplyr, summarize(), recolhe o conjunto de dados em uma única linha. Digamos que estamos interessados em saber o tamanho médio do download. summarize(cran, avg_bytes = mean(size)) produzirá o valor médio da variável size. Aqui escolhemos rotular o resultado como 'avg_bytes', mas poderíamos ter chamado qualquer coisa. Verifique você mesmo!
  CorrectAnswer: summarize(cran, avg_bytes = mean(size))
  AnswerTests: omnitest('summarize(cran, avg_bytes = mean(size))')
  Hint: summarize(cran, avg_bytes = mean(tamanho)) nos fornecerá o tamanho médio e rotulará o resultado como 'avg_bytes'.

- Class: text
  Output: Isso não é particularmente interessante. summarize() é mais útil ao trabalhar com dados que foram agrupados (group_by) pelos valores de uma variável específica.

- Class: text
  Output: Examinaremos os dados agrupados na próxima lição, mas a idéia é que summarize() pode fornecer o valor solicitado para cada grupo no seu conjunto de dados.

- Class: text
  Output: Nesta lição, você aprendeu como manipular dados usando as cinco principais funções do dplyr. Na próxima lição, veremos como tirar proveito de outros recursos úteis do dplyr para tornar sua vida como analista de dados muito mais fácil.

- Class: mult_question
  Output: Gostaria de informar ao seu instrutor sobre sua conclusão bem-sucedida desta lição? 
  CorrectAnswer: NULL
  AnswerChoices: Sim;Nao
  AnswerTests: submit_log()
  Hint: É importante deixar seu instrutor saber que você terminou a lição.
  
